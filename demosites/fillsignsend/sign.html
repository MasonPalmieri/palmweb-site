<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Client Portal — Sign</title>
  <link rel="stylesheet" href="assets/app.css" />
</head>
<body class="app light">

  <header class="topbar">
    <div class="brand">
      <div class="logo">FSS</div>
      <div>
        <div class="title" id="roomTitle">Signing Room</div>
        <div class="sub" id="roomSub">Loading…</div>
      </div>
    </div>

    <nav class="navlinks">
      <a href="dashboard.html">Dashboard</a>
      <a href="create.html">Create</a>
      <a href="audit.html">Audit</a>
      <a href="../../demos.html" id="logoutBtn">Logout</a>
    </nav>
  </header>

  <main class="page">
    <div class="shell">

      <section class="panel">
        <div class="panelHead">
          <div>
            <h2 style="margin:0;" id="docTitle">Sign Document</h2>
            <p class="muted" style="margin:6px 0 0;" id="docLine">Loading…</p>
          </div>

          <div class="topActions">
            <button class="btn secondary" id="prevPageBtn" type="button">◀</button>
            <div class="pill" id="pagePill">Page 1 / 1</div>
            <button class="btn secondary" id="nextPageBtn" type="button">▶</button>

            <button class="btn ghost" id="nextFieldBtn" type="button">Next Field</button>
            <button class="btn primary" id="primaryActionBtn" type="button">Complete</button>
          </div>
        </div>

        <div class="divider"></div>

        <div class="signLayout">
          <!-- LEFT PANEL -->
          <aside class="sidePanel">
            <div class="sideBlock">
              <b>Fields</b>
              <div class="toolRow">
                <button class="tool active" data-tool="signature" type="button">Signature</button>
                <button class="tool" data-tool="date" type="button">Date</button>
                <button class="tool" data-tool="initials" type="button">Initials</button>
                <button class="tool" data-tool="text" type="button">Text</button>
                <button class="tool" data-tool="checkbox" type="button">Checkbox</button>
              </div>
              <p class="tiny muted" style="margin-top:10px;">
                Click a field type, then click on the document to place it.
              </p>
            </div>

            <div class="divider"></div>

            <div class="sideBlock">
              <b id="signerLabel">Signer</b>
              <div class="cardInfo" id="partyBox">Loading…</div>

              <div class="divider"></div>

              <b>Required</b>
              <p class="tiny muted" style="margin-top:6px;" id="requiredLine">
                Required: Signature + Date
              </p>
            </div>

            <div class="divider"></div>

            <button class="btn outlineFull" id="clearFieldsBtn" type="button">Clear Fields</button>
          </aside>

          <!-- DOCUMENT -->
          <div class="docWrap">
            <div class="docBar">
              <span class="pill">PDF</span>
              <span class="muted tiny" id="fileName"></span>
              <span class="muted tiny" style="margin-left:auto;" id="zoomLabel">Zoom: 100%</span>
              <button class="btn miniBtn" id="zoomOut" type="button">–</button>
              <button class="btn miniBtn" id="zoomIn" type="button">+</button>
            </div>

            <div class="docStage">
              <canvas id="pdfCanvas"></canvas>
              <div id="overlay" class="overlay"></div>
            </div>

            <p class="tiny" id="statusLine" style="margin-top:10px;"></p>
          </div>
        </div>
      </section>

    </div>
  </main>

  <!-- PDF.js (CDN) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.min.mjs" type="module"></script>
  <script src="assets/app.js"></script>

  <script type="module">
    FSS.guard();

    const { pdfjsLib } = globalThis;
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.worker.min.mjs";

    // UI refs
    const canvas = document.getElementById("pdfCanvas");
    const overlay = document.getElementById("overlay");
    const statusLine = document.getElementById("statusLine");

    const fileName = document.getElementById("fileName");
    const docLine = document.getElementById("docLine");
    const pagePill = document.getElementById("pagePill");

    const prevPageBtn = document.getElementById("prevPageBtn");
    const nextPageBtn = document.getElementById("nextPageBtn");
    const nextFieldBtn = document.getElementById("nextFieldBtn");
    const primaryActionBtn = document.getElementById("primaryActionBtn");
    const clearFieldsBtn = document.getElementById("clearFieldsBtn");

    const zoomLabel = document.getElementById("zoomLabel");
    const zoomOut = document.getElementById("zoomOut");
    const zoomIn = document.getElementById("zoomIn");

    const roomTitle = document.getElementById("roomTitle");
    const roomSub = document.getElementById("roomSub");
    const signerLabel = document.getElementById("signerLabel");
    const requiredLine = document.getElementById("requiredLine");

    const toolBtns = document.querySelectorAll(".tool");

    // Role
    const params = new URLSearchParams(location.search);
    const role = (params.get("role") || "recipient").toLowerCase(); // sender | recipient

    const state = FSS.loadDocState();
    if(!state?.template){
      window.location.href = "create.html";
    }

    // If sender is done and recipient tries sender page, push them to recipient
    if(role === "sender" && state.stage === "recipient"){
      window.location.href = "sign.html?role=recipient";
    }

    if(role === "sender"){
      roomTitle.textContent = "Sender Signing";
      roomSub.textContent = "Party A signs first. Then send to recipient.";
      signerLabel.textContent = "Sender (Party A)";
      primaryActionBtn.textContent = "Send to Recipient";
    } else {
      roomTitle.textContent = "Recipient Signing";
      roomSub.textContent = "Party B signs after receiving the envelope.";
      signerLabel.textContent = "Recipient (Party B)";
      primaryActionBtn.textContent = "Complete";
    }

    fileName.textContent = state.template;
    docLine.textContent = `Template: ${state.template}`;

    // Display signer
    const partyBox = document.getElementById("partyBox");
    const p = state.parties || {};
    if(role === "sender"){
      partyBox.innerHTML = `
        <b>${FSS.escape(p.aName || "Sender")}</b><br/>
        <span class="muted">${FSS.escape(p.aEmail || "")}</span>
        <div class="divider" style="margin:12px 0;"></div>
        <span class="tiny muted">Recipient:</span><br/>
        <b>${FSS.escape(p.bName || "")}</b><br/>
        <span class="muted">${FSS.escape(p.bEmail || "")}</span>
      `;
    } else {
      partyBox.innerHTML = `
        <b>${FSS.escape(p.bName || "Recipient")}</b><br/>
        <span class="muted">${FSS.escape(p.bEmail || "")}</span>
        <div class="divider" style="margin:12px 0;"></div>
        <span class="tiny muted">Sender:</span><br/>
        <b>${FSS.escape(p.aName || "")}</b><br/>
        <span class="muted">${FSS.escape(p.aEmail || "")}</span>
      `;
    }

    // Audit: viewed
    if(role === "recipient"){
      FSS.auditAddOnce("Viewed", "Recipient opened the envelope.");
    }

    // Fields
    let fields = FSS.loadFields();
    let selectedTool = "signature";

    // PDF rendering
    let pdfDoc = null;
    let pageCount = 1;
    let currentPage = 1;
    let scale = 1.15; // default slightly zoomed in for readability

    // Required model: signature + date are required for BOTH roles,
    // but we enforce they are done twice: sender must sign+date at least once, recipient must sign+date at least once.
    requiredLine.textContent = "Required: Signature + Date";

    // Render page
    async function renderPage(pageNum){
      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale });

      const ctx = canvas.getContext("2d");
      canvas.width = viewport.width;
      canvas.height = viewport.height;

      // store canvas size for PDF stamping mapping
      localStorage.setItem("fss_last_canvas_size", JSON.stringify({ w: canvas.width, h: canvas.height }));

      overlay.style.width = viewport.width + "px";
      overlay.style.height = viewport.height + "px";

      await page.render({ canvasContext: ctx, viewport }).promise;

      pagePill.textContent = `Page ${pageNum} / ${pageCount}`;
      zoomLabel.textContent = `Zoom: ${Math.round(scale * 100)}%`;

      renderOverlay();
    }

    function renderOverlay(){
      overlay.innerHTML = "";

      // show all fields on current page, but visually label who owns it
      const pageFields = fields.filter(f => f.page === currentPage);

      for(const f of pageFields){
        const el = document.createElement("div");
        el.className = `field ${f.value ? "filled" : ""} ${f.required ? "required" : ""}`;
        el.style.left = f.x + "px";
        el.style.top = f.y + "px";
        el.style.width = f.w + "px";
        el.style.height = f.h + "px";
        el.setAttribute("data-id", f.id);

        const top = document.createElement("div");
        top.className = "fieldTop";
        top.textContent = `${f.type.toUpperCase()} • ${f.owner.toUpperCase()}${f.required ? " *" : ""}`;
        el.appendChild(top);

        const body = document.createElement("div");
        body.className = "fieldBody";
        body.textContent = f.value ? f.value : "Click to fill";
        el.appendChild(body);

        // delete button only if you are the owner of the field
        if(f.owner === role){
          const del = document.createElement("button");
          del.type = "button";
          del.className = "fieldDel";
          del.textContent = "✕";
          del.title = "Remove field";
          del.addEventListener("click", (e) => {
            e.stopPropagation();
            fields = fields.filter(x => x.id !== f.id);
            FSS.saveFields(fields);
            renderOverlay();
          });
          el.appendChild(del);
        }

        // only allow filling your own fields
        el.addEventListener("click", () => {
          if(f.owner !== role){
            statusLine.textContent = "This field belongs to the other signer.";
            statusLine.className = "tiny textWarn";
            return;
          }
          openFillModal(f.id);
        });

        overlay.appendChild(el);
      }
    }

    function openFillModal(fieldId){
      const f = fields.find(x => x.id === fieldId);
      if(!f) return;

      if(f.type === "checkbox"){
        f.value = f.value ? "" : "☑";
        FSS.saveFields(fields);
        renderOverlay();
        return;
      }

      if(f.type === "date"){
        const d = new Date();
        const val = `${String(d.getMonth()+1).padStart(2,"0")}/${String(d.getDate()).padStart(2,"0")}/${d.getFullYear()}`;
        f.value = val;
        FSS.saveFields(fields);
        renderOverlay();
        return;
      }

      let label = "Enter value";
      let placeholder = "";
      let defaultVal = f.value || "";

      if(f.type === "signature"){
        label = "Type your full name (Signature)";
        placeholder = role === "sender" ? (p.aName || "Your name") : (p.bName || "Your name");
      }
      if(f.type === "initials"){
        label = "Type your initials";
        placeholder = "Example: JS";
      }
      if(f.type === "text"){
        label = "Enter text";
        placeholder = "Type here…";
      }

      const val = window.prompt(label, defaultVal || placeholder);
      if(val === null) return;

      f.value = val.trim();
      FSS.saveFields(fields);
      renderOverlay();
    }

    function getRequiredFieldsForRole(){
      // Required fields placed by this signer
      const mine = fields.filter(f => f.owner === role && f.required);
      return mine;
    }

    function ensureRoleHasSignatureAndDate(){
      const mine = fields.filter(f => f.owner === role);
      const hasSig = mine.some(f => f.type === "signature");
      const hasDate = mine.some(f => f.type === "date");
      return { hasSig, hasDate };
    }

    function getNextUnfilledRequired(){
      const mineReq = getRequiredFieldsForRole();
      for(const f of mineReq){
        if(!f.value) return f;
      }
      return null;
    }

    function focusField(f){
      if(!f) return;

      if(currentPage !== f.page){
        currentPage = f.page;
        renderPage(currentPage).then(() => flashField(f.id));
      } else {
        flashField(f.id);
      }
    }

    function flashField(id){
      const el = overlay.querySelector(`[data-id="${id}"]`);
      if(!el) return;
      el.classList.add("flash");
      el.scrollIntoView({ behavior:"smooth", block:"center", inline:"center" });
      setTimeout(()=> el.classList.remove("flash"), 900);
    }

    // Place fields
    overlay.addEventListener("click", (e) => {
      if(e.target.closest(".field")) return;

      const rect = overlay.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const size = FSS.fieldDefaults(selectedTool);

      const field = {
        id: crypto.randomUUID(),
        type: selectedTool,
        page: currentPage,
        x: Math.max(10, x - size.w / 2),
        y: Math.max(10, y - size.h / 2),
        w: size.w,
        h: size.h,
        required: size.required,
        value: "",
        owner: role
      };

      fields.push(field);
      FSS.saveFields(fields);
      renderOverlay();

      statusLine.textContent = `Placed ${selectedTool.toUpperCase()} on page ${currentPage}. Click it to fill.`;
      statusLine.className = "tiny textGood";
    });

    toolBtns.forEach(btn => {
      btn.addEventListener("click", () => {
        toolBtns.forEach(x => x.classList.remove("active"));
        btn.classList.add("active");
        selectedTool = btn.getAttribute("data-tool");
        statusLine.textContent = `Selected: ${selectedTool.toUpperCase()} — click on the PDF to place it.`;
        statusLine.className = "tiny textWarn";
      });
    });

    // Page controls
    prevPageBtn.addEventListener("click", () => {
      if(currentPage > 1){
        currentPage -= 1;
        renderPage(currentPage);
      }
    });

    nextPageBtn.addEventListener("click", () => {
      if(currentPage < pageCount){
        currentPage += 1;
        renderPage(currentPage);
      }
    });

    // Zoom
    zoomIn.addEventListener("click", () => {
      scale = Math.min(1.7, scale + 0.08);
      renderPage(currentPage);
    });
    zoomOut.addEventListener("click", () => {
      scale = Math.max(0.9, scale - 0.08);
      renderPage(currentPage);
    });

    // Next required field
    nextFieldBtn.addEventListener("click", () => {
      const next = getNextUnfilledRequired();
      if(!next){
        statusLine.textContent = "All required fields for you are completed ✅";
        statusLine.className = "tiny textGood";
        return;
      }
      focusField(next);
      statusLine.textContent = "Jumped to your next required field.";
      statusLine.className = "tiny textGood";
    });

    // Clear fields for role only (safer)
    clearFieldsBtn.addEventListener("click", () => {
      if(!confirm("Clear ONLY your placed fields?")) return;
      fields = fields.filter(f => f.owner !== role);
      FSS.saveFields(fields);
      renderOverlay();
      statusLine.textContent = "Your fields cleared.";
      statusLine.className = "tiny textWarn";
    });

    // Primary action (Send / Complete)
    primaryActionBtn.addEventListener("click", async () => {
      // Enforce this signer placed signature + date
      const { hasSig, hasDate } = ensureRoleHasSignatureAndDate();
      if(!hasSig || !hasDate){
        alert("You must place at least:\n\n• Signature field\n• Date field\n\nThen fill them.");
        return;
      }

      // Enforce required filled for this signer
      const unfilled = getNextUnfilledRequired();
      if(unfilled){
        alert("A required field is missing.\n\nWe will take you to it now.");
        focusField(unfilled);
        return;
      }

      // If sender => send to recipient
      if(role === "sender"){
        FSS.auditAdd("Sender Signed", "Sender completed required fields.");

        // Move state forward
        FSS.saveDocState({
          ...state,
          status: "sent",
          stage: "recipient",
          sentAt: Date.now()
        });

        // Create signing link (demo)
        const base = `${window.location.origin}${window.location.pathname.replace("sign.html","")}`;
        const link = `${base}sign.html?role=recipient`;

        // Log
        FSS.auditAdd("Sent", "Envelope sent to recipient.");

        // Show prompt and auto go to recipient signing
        const ok = confirm(
          "Sender signing complete ✅\n\nEnvelope is now ready to send.\n\nClick OK to copy the recipient signing link and continue as recipient."
        );

        if(ok){
          try{
            await navigator.clipboard.writeText(link);
          }catch{}
          window.location.href = "sign.html?role=recipient";
          return;
        }

        // If they cancel, return to dashboard
        window.location.href = "dashboard.html";
        return;
      }

      // Recipient => complete and generate signed pdf
      statusLine.textContent = "Generating signed PDF…";
      statusLine.className = "tiny textWarn";

      try{
        const pdfUrl = `pdfs/${state.template}`;
        const bytes = await FSS.fetchArrayBuffer(pdfUrl);

        const signedBytes = await FSS.generateSignedPdf({
          originalPdfBytes: bytes,
          fields,
          parties: state.parties || {}
        });

        FSS.auditAdd("Recipient Signed", "Recipient completed required fields.");
        FSS.auditAdd("Completed", "Signed PDF generated.");

        FSS.saveSignedBlob(signedBytes, state.template);

        statusLine.textContent = "Completed ✅ Redirecting…";
        statusLine.className = "tiny textGood";

        setTimeout(() => {
          window.location.href = "success.html";
        }, 650);

      }catch(err){
        console.error(err);
        statusLine.textContent = "Error generating signed PDF.";
        statusLine.className = "tiny textBad";
      }
    });

    document.getElementById("logoutBtn").addEventListener("click", () => {
      FSS.logout();
    });

    // Load PDF
    (async function init(){
      try{
        const pdfUrl = `pdfs/${state.template}`;
        const loadingTask = pdfjsLib.getDocument(pdfUrl);
        pdfDoc = await loadingTask.promise;
        pageCount = pdfDoc.numPages;

        // Remove any fields out of bounds
        fields = (fields || []).filter(f => f.page >= 1 && f.page <= pageCount);
        FSS.saveFields(fields);

        await renderPage(currentPage);

        statusLine.textContent = role === "sender"
          ? "Sender: place Signature + Date, fill them, then click “Send to Recipient”."
          : "Recipient: place Signature + Date, fill them, then click “Complete”.";
        statusLine.className = "tiny textGood";
      }catch(err){
        console.error(err);
        statusLine.textContent = "Could not load PDF. Confirm file exists in /pdfs/.";
        statusLine.className = "tiny textBad";
      }
    })();
  </script>
</body>
</html>
